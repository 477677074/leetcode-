## 5月28日 统计作战单位数

--------

 n 名士兵站成一排。每个士兵都有一个 独一无二 的评分 rating 。

每 3 个士兵可以组成一个作战单位，分组规则如下：


	从队伍中选出下标分别为 i、j、k 的 3 名士兵，他们的评分分别为 rating[i]、rating[j]、rating[k]
	作战单位需满足： rating[i] < rating[j] < rating[k] 或者 rating[i] > rating[j] > rating[k] ，其中  0 <= i < j < k < n


请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。

 

示例 1：

输入：rating = [2,5,3,4,1]
输出：3
解释：我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。


示例 2：

输入：rating = [2,1,3]
输出：0
解释：根据题目条件，我们无法组建作战单位。

难度：==中等==

代码演示：

```[c]
int numTeams(int* rating, int ratingSize)
{
    int total = 0;
    for (int i = 0; i < ratingSize; i++) 
    {
        int first = rating[i];
        for (int j = i+1; j < ratingSize; j++)
         {
            if (first < rating[j])
             {
                int second = rating[j];
                for (int k = j+1; k < ratingSize; k++)
                {
                    if (second < rating[k]) total++;
                }
            }
            if (first > rating[j]) 
            {
                int second = rating[j];
                for (int k = j+1; k < ratingSize; k++)
                {
                    if (second > rating[k])
                        total++;
                }
            }
        }
    }
    return total;
}
```



执行结果:通过

执行用时 :24 ms, 在所有 C 提交中击败了78.27% 的用户

内存消耗 :5.5 MB, 在所有 C 提交中击败了100.00%的用户

- **这种暴力解法利用三个循环效能相对较低但是思路容易想**



代码演示：

```[c]
int numTeams(int* rating, int ratingSize){
    int total = 0;
    for (int j = 1; j < ratingSize - 1; j++) {
        int second = rating[j];
        int i_min = 0;
        int i_max = 0;
        for (int i = 0; i < j; i++){
            if (rating[i] < second)
                i_min++;
            if (rating[i] > second)
                i_max++;
        }

        int k_min = 0;
        int k_max = 0;
        for (int k = j+1; k < ratingSize; k++){
            if (rating[k] < second)
                k_min++;
            if (rating[k] > second)
                k_max++;
        }
        total += i_min * k_max + i_max * k_min;
    }
    return total;
}

```

执行结果：通过

执行用时 :0 ms, 在所有 C 提交中击败了100.00% 的用户

内存消耗 :5.5 MB, 在所有 C 提交中击败了100.00%的用户

- **这种方法利用最中间的元素进行遍历只需要两次循环效率高很多**

- **颇有一点二分查找的意思**

## 5月29日 查询带键的排列

--------

给你一个待查数组 `queries` ，数组中的元素为 `1`到 `m` 之间的正整数。 请你根据以下规则处理所有待查项 `queries[i]`（从 i=0 到 i=queries.length-1）：


	一开始，排列 P=[1,2,3,...,m]。
	对于当前的 i ，请你找出待查项 queries[i] 在排列 P 中的位置（下标从 0 开始），然后将其从原位置移动到排列 P 的起始位置（即下标为 0 处）。注意， queries[i] 在 P 中的位置就是 queries[i] 的查询结果。


请你以数组形式返回待查数组 ` queries `的查询结果。

 

示例 1：

输入：`queries = [3,1,2,1], m = 5`
输出：`[2,1,2,1] `
解释：`待查数组 queries 处理如下：`
`对于 i=0: queries[i]=3, P=[1,2,3,4,5], 3 在 P 中的位置是 2，接着我们把 3 移动到 P 的起始位置，得到 P=[3,1,2,4,5] 。
对于 i=1: queries[i]=1, P=[3,1,2,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,3,2,4,5] 。 
对于 i=2: queries[i]=2, P=[1,3,2,4,5], 2 在 P 中的位置是 2，接着我们把 2 移动到 P 的起始位置，得到 P=[2,1,3,4,5] 。
对于 i=3: queries[i]=1, P=[2,1,3,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,2,3,4,5] 。 `
因此，返回的结果数组为 [2,1,2,1] 。  


示例 2：

输入：`queries = [4,1,2,2], m = 4`
输出：`[3,1,2,0]`


示例 3：

输入：`queries = [7,5,5,8,3], m = 8`
输出：`[6,5,0,7,5]`

难度：==中等==

代码演示：

```[c]
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* processQueries(int* queries, int queriesSize, int m, int* returnSize)
{
    int* ret = (int*)calloc(queriesSize, sizeof(int));
    int* ans = (int*)calloc(m, sizeof(int));
    
    ret[0] = queries[0] - 1;
    
    for (int i = 0; i < m; i++) 
    {
        ans[i] = i + 1;
    }
    
    for (int i = 1; i < queriesSize; i++) 
    {
        int temp = ans[ret[i - 1]];
        for (int j = ret[i - 1]; j >= 1; j--) 
        {
            ans[j] = ans[j - 1];
        }
        ans[0] = temp;
        
        for (int index = 0; index < m; index++) 
        { 
            if (queries[i] == ans[index]) 
            {
                ret[i] = index;
                break;
            }
        }
    }   
    *returnSize = queriesSize;
    return ret;
}
```

执行结果：通过

执行用时 :8 ms, 在所有 C 提交中击败了98.28% 的用户

内存消耗 :5.8 MB, 在所有 C 提交中击败了100.00%的用户



- **暴力法直接解题效果还不错**



## 5月30日 反转数组

--------

给你一幅由` N × N `矩阵表示的图像，其中每个像素的大小为 `4 `字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

 

示例 1:

给定 matrix = 
`[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],`

原地旋转输入矩阵，使其变为:
`[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]`


示例 2:

给定 matrix =
`[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], `

原地旋转输入矩阵，使其变为:
`[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]`

难度：==中等==

代码演示：

```[c]
void rotate(int** matrix, int matrixSize, int* matrixColSize)
{
    int i,j;
    int len = * matrixColSize;
    int temp[len][len];
    for(i=0;i<len;i++)
    {
        for(j=0;j<len;j++)
        {
            temp[j][len-1-i] = matrix[i][j];
        }
    }
    for(i=0;i<len;i++)
    {
        for(j=0;j<len;j++)
        {
            matrix[i][j]=temp[i][j];
        }
    }
}

```



- **这道题最重要的便是找到反转前后数组的坐标之间的关系和规律**

附上两张题解中的图：

![](LeetCode习题.assets/旋转数组1.png)





![](LeetCode习题.assets/旋转数组2.png)



红色轴为反转后的的坐标轴，寻找规律一目了然
